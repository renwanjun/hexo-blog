---
title: JavaScript事件循环机制
date: 2020-03-12 20:53:23
tags:
---
前言
===========================================
希望通过这篇文章，了解到Event Loop到底是一种什么机制，浏览器和NodeJS的Event Loop又有什么区别。

从浏览器多进程到JS单线程，再到JS引擎的运行机制系统。
## 并行处理
在理解进程和线程之前，首先需要了解的就是并行处理，理解了并行处理之后，再理解进程和线程就会容易很多。
所谓并行处理就是说计算机在同一个时刻处理多个任务，比如计算下面三个表达式的值，并显示出结果：

    A = 1 + 1
    B = 2 + 2
    C = 3 + 3
按照正常的执行流程，下面的流程会这样执行：

    * 任务 1 是计算 A=1+1；
    * 任务 2 是计算 B=2+2；
    * 任务 3 是计算 C=3+3；
    * 任务 4 是显示最后计算的结果。
上面的执行流程就是单线程处理。
如果使用多线程处理，我们只需要分2步即可完成上面的任务，第1步：使用三个线程同时执行前三个任务；第2步，再执行第四个显示任务。

通过对比分析，你会发现用单线程执行需要四步，而使用多线程只需要两步。

因此，使用多线程并行处理能大大提升性能。
## 进程和线程
多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来管理和启动的。
### 进程
一个进程就是一个程序的运行实例。
详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是cpu资源分配的最小单位（系统会给他分配内存）。
### 线程
线程是依附于进程的，而进程中使用多线程来并行处理能提升元算效率。

## 浏览器是多进程的
浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）

简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。
**注意：**在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了。
（所以每一个Tab标签对应一个进程并不一定是绝对的）
### 浏览器包含哪些进程
知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）

1.**Browser进程**：浏览器的主进程（负责协调、主控），**每个浏览器只有一个**。作用有负责浏览器界面显示，与用户交互，如前进，后退等。负责各个页面的管理，创建和销毁其他进程。将Renderer进程得到的内存中的Bitmap绘制到用户界面上，网络资源的管理，下载等  
2.**第三方插件进程**：每种类型的插件对应一个进程，仅当使用该插件时才创建  
3.**GPU进程**：最多一个，用于3D绘制等  
4.**浏览器渲染进程（浏览器内核）**（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为页面渲染，脚本执行，事件处理等  

**强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）**
### 浏览器的渲染进程是多线程的
对于普通的前端来说，最需要要了解的就是渲染进程

1.GUI渲染进程   

负责渲染浏览器界面，解析HTML、CSS，构建DOM树和RenderObject树，布局和绘制等。  
并且当界面需要重绘(Repainting)或由于某种操作引发回流(Reflow)时，该线程就会执行。  
注意，**<font color="red">GUI渲染线程与JS引擎线程是互斥的</font>**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2.JS引擎线程  
也称为JS内核，负责处理Javascript脚本程序（例如V8引擎）。JS引擎线程负责解析Javascript脚本，运行代码。JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3.事件触发线程

归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）

当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中。当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。

注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

4.定时触发器线程

传说中的setInterval与setTimeout所在线程

浏览器定时计数器并不是由JavaScript引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确。因此**通过单独线程来计时并触发定时**，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行。

注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

5.异步HTTP请求线程
XMLHttpRequest在连接后是通过浏览器新开一个线程请求，在检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

### 浏览器多进程的优势TODO
### Browser进程和浏览器内核（Render进程）的通信过程
打开任务管理器并打开一个浏览器，可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程），然后在这前提下，看下整个的过程：(简化了很多)    
Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通RendererHost接口传递给Render进程。  

Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染。  

渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。  

当然可能会有JS线程操作DOM（这样可能会造成回流并重绘。  

最后Render进程将结果传递给Browser进程，Browser进程接收到结果并将结果绘制出来。

## 浏览器内核中线程之间的关系
GUI渲染线程与JS引擎线程互斥
JS阻塞页面加载
## 宏任务和微任务
https://www.jianshu.com/p/f1e5ad3b4afb
